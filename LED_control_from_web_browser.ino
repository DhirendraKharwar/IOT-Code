//***************************** READ INSTRUCTIONS CAREFULLY ************************************
// THIS PROGRAM IS FOR CONTROLLING LED OR ANY OUTPUT DEVICE CONNECTED TO NODEMCU FROM
// WEB BROWSER WITH HELP OF SIMPLE HTML PROGRAMMING. THIS PROGRAM CAN BE WRITTEN IN MANY
// WAYS. THIS IS MOST SIMPLEST PROGRAM AND IS SLIGHTLY DIFFERENT THAN ONE WHICH SHOWN IN 
// DEMO VIDEO OF WORKSHOP. THIS WILL ALSO PERFORM SAME TASK OF DEVICE CONTROL FROM WEB
// BROWSER WITH STATUS IN BRWOSER ITSELF. TO ADD EVEN MORE FUNCTIONALITIES & DESIGN DETAILING,
// MORE KNOLWDGE OF HTML & CSS IS REQUIRED. 

// LET'S STUDY SIMPLE PROGRAM.
// ********************************************************************************************  
// CONTROLLING THE DEVICES FROM WEB BROWSER


// INCLUDE THE BASE LIBRARY.IT CAN MANGE ONLY ON BASE LIBRARY ALSO. 
// BUT YOU CAN USE CLIENT SERVER LIBRARIES FOR MORE FUNCTIONS.
#include <ESP8266WiFi.h> 

// ADDING WIFI CREDENTIALS. YOU CAN USE MOBILE HOTSPOT ALSO
const char* ssid = "vivo 17144";
const char* password = "";

// COMMENT PREVIOUS LINE & UNCOMMENT FOLLOWING LINE IF YOU DONT HAVE PASSWORD FOR YOUR WIFI NETWORK. 
// const char* password = "";    //DO NOT WRITE ANYTHING IN BETWEEN "". NOT EVEN WHITESPACE. LEAVE IT AS IT IS. 

int LED1 = D1;                 // LED CONNECTED TO D1
int LED2 = D2;
int LED3 = D3;
WiFiServer server(80);        // CREATING AN OBJECT WITH HTTP PORT FOR WIFISERVER CLASS
 
void setup(void) 
{
  Serial.begin(9600);       // SERIAL COMMUNICATION ENABLED AT 9600 BAUD RATE (9600 DATA BITS/SECOND)
  pinMode(LED1, OUTPUT);     // DECLARE D1 PIN AS OUTPUT PIN
  digitalWrite(LED1, LOW);   // SET D1 PIN I.E. LED LOW BY DEFAULT

  pinMode(LED2, OUTPUT);     // DECLARE D1 PIN AS OUTPUT PIN
  digitalWrite(LED2, LOW);   // SET D1 PIN I.E. LED LOW BY DEFAULT

  pinMode(LED3, OUTPUT);     // DECLARE D1 PIN AS OUTPUT PIN
  digitalWrite(LED3, LOW);   // SET D1 PIN I.E. LED LOW BY DEFAULT
 
  Serial.print("Connecting to Internet ");    // START PRINTING STATUS ON SERIAL MONITOR
  WiFi.begin(ssid, password);       // INITIATE THE WIFI CONNECTION
  while (WiFi.status() != WL_CONNECTED)     // WAIT UNTIL NODEMCU GETS CONNECTED TO ROUTER
  {
    delay(500);
    Serial.print(".");
  }
  Serial.println("WiFi connected");
// WIFI CONNECTION PART IS SUCCESFULLY COMPLETED. NOW RETRIEVE THE IP ADDRESS & START THE SERVER
 
  server.begin();    // INITIATE THE SERVER
  Serial.println("Server started");
  
  Serial.print("IP Address of network: ");
  Serial.println(WiFi.localIP());
  Serial.print("USE THIS IP ADDRESS TO GET CONNECTED : ");
  Serial.print(WiFi.localIP());    // FECH THE IP ADDRESS PROVIDED BY ROUTER & PRINT ON SERIAL MONITOR
}


// ALL MAIN FUNCTIONALITIES NOW STARTS IN VOID LOOP
void loop() 
  {
    // CREATE OBJECT FOR CLIENT AND CHECK FOR THE SERVER CONNECTION.
    // IN SIMPLE CLIENT SERVER DEMO, CLIENT OBJECT WAS NOT REQUIRED BECAUSE THERE WAS NO ANY ACTIVE 
    // COMMUNICATION PERFORMED FROM WEB PAGE. IT WAS JUST A STATIC OUTPUT (SIMPLE MESSAGE) GENERATED 
    // AS HARDCODED IN NODEMCU. BUT IN THIS PROGRAM WE ARE GOING TO SEND DYNAMIC REQUESTS FROM WEBPAGE 
    // I.E. TURNING ON & OFF COMMANDS TO SERVER(NODEMCU). SO IT IS NEEDED TO CREATE CLIENT OBJECT TO WHICH 
    // THE SERVER OBJECT IS LISTENING CONTINUOUSLY. 
    // FOLLOW THIS LINK FOR DETAILS : https://www.arduino.cc/en/Reference/WiFiServerAvailable
     
    WiFiClient client = server.available();   // GETS A CLIENT THAT IS AVAILABLE & HAS DATA AVAILABLE FOR READING.    
    if (!client) 
    {
      return;
    }
  Serial.println("Waiting for new client");   // AFTER CLICKING ONCE ON ANY BUTTON, WAIT FOR NEXT COMMAND.
  while(!client.available())
  {
    delay(1);
  }

 // WHEN YOU CLICK ON BUTTON, DATA FETCHED FROM BROWSER & STORED IN STRING FORMAT.
  String request = client.readStringUntil('\r'); // \r IS CONTROL CHARACTER OR TERMINATOR WHICH HELPS TO RECIEVE THE WHOLE ACTION
                                                 // COMMAND WHICH IS SET BY THE CLIENT AS REQUEST.
  Serial.println(request);  // PRINTS THE USER REQUEST I.E. TURN ON OR TURN OFF
  client.flush();       // THIS IS TO CLEAR THE BUFFER USED FOR LAST EXECUTED RESPONSE TO ALLOW NEXT REQUEST FROM CLIENT.
 
 
  int value = LOW;      // THIS VARIABLE IS USED TO DISPLAY STATUS OF USER'S LAST ACTION ON BROWSER I.E. ABOUT TURNED ON OR OFF
                        // SERVER WILL SEND THIS VARIABLE TO CLIENT (BROWSER) AS RESPONSE OF LAST EXECUTED REQUEST BY USER/CLIENT. 
  
  
  // LED TURNING ON WHEN USER CLICKS TURN ON BUTTON. PLEASE USE SERIAL MONITOR TO UNDERSTAND THE FOLLOWING OUTPUT
  if (request.indexOf("/LED=ON") != -1)  // IF THE REQUEST STRING CONSISTS OF /LED=ON(CHECK LINE NO. 137 IN CODE) THEN DO NEXT ACTION  
  {
    digitalWrite(LED1, HIGH);      // ACTION WILL BE TAKEN ON LED
    digitalWrite(LED2, HIGH);      // ACTION WILL BE TAKEN ON LED
    digitalWrite(LED3, HIGH);      // ACTION WILL BE TAKEN ON LED
    value = HIGH;                 // RESPONSE VALUE WILL BE INDICATED AS HIGH. IT WILL BE DIPLAYED IN BROWSER ITSELF.
  }

  // LED TURNING ON WHEN USER CLICKS TURN OFF BUTTON
  if (request.indexOf("/LED=OFF") != -1)  // IF THE REQUEST STRING CONSISTS OF /LED=OFF(CHECK LINE NO. 138 IN CODE) THEN DO NEXT ACTION
  {
    digitalWrite(LED1, LOW);       // ACTION WILL BE TAKEN ON LED
    digitalWrite(LED2, LOW);       // ACTION WILL BE TAKEN ON LED
    digitalWrite(LED3, LOW);       // ACTION WILL BE TAKEN ON LED
    value = LOW;                  // RESPONSE VALUE WILL BE INDICATED AS LOW. IT WILL BE DIPLAYED IN BROWSER ITSELF.
  }
  

// ***************************** MOST IMPORTANT TO NOTE ******************************
// HTML CODE FOR CREATING WEB PAGE WITH BUTTONS INTERFACE.
// HTML CODE NEVER RUNS ON NODEMCU, IT ALWAYS RUNS ONLY IN WEB BROWSER. 
// FOLLOWING CODE OF NODEMCU JUST HOLDS THE HTML CODE IN PRINT STATMENTS.
// THIS PRINT STATEMENTS ARE MADE OR EXECUTED FOR CLIENT OBJECT.
// MEANS SERVER IS RESPONSIBLE TO SEND THE ENTIRE HTML CODE TO WEB BROWSER I.E. CLIENT, LINE BY LINE.
// THIS CODE IS BEING SENT TO THE CLIENT WHEN CLIENT CALLS THE IP ADDRESS AND HTML PAGE GETS DISPLAYED ON BROWSER. 
// BROWSER RECEIVES THE HTML CODE LINES FROM NODEMCU WHICH RESULTS INTO A WEBPAGE.
// SO ALL NEXT PRINT STATEMENTS WILL BE APPENDED TO CLIENT OBJECT.  
// FOLLOW THIS LINK TO UNDERSTAND HTML : https://www.w3schools.com/html/

  client.println("HTTP/1.1 200 OK");    // SEND STATUS AS OK. 200 = OK
  client.println("Content-Type: text/html");   // SET DATA FORMAT AS HTML
  client.println(""); 
  client.println("<!DOCTYPE HTML>");
  client.println("<html>");      // FIRST OPENING TAG OF HTML CODE
 
  client.print("LED is: ");     // TO DIPLAY THE STATUS OF LED / DEVICE IN BROWSER
 
  if(value == HIGH)       // IF VALUE IS SET TO HIGH (CHECK LINE N0. 91 IN CODE), THEN PRINT AS ON   
  {
    client.print("ON");
  } 
  else                   // IF VALUE IS SET TO LOW (CHECK LINE N0. 98 IN CODE), THEN PRINT AS OFF
  {
    client.print("OFF");
  }
  client.println("<br><br>");    // LINE BREAK STATEMENT. FOLLOW LINK GIVEN ABOVE FOR MORE DETAILS.

  

  // CREATING BUTTONS WITH ACTION / REQUEST COMMAND.
  // FOR TURN ON BUTTON, REQUEST / ACTION COMMAND WILL BE : /LED=ON (POST-RELATES TO LINE NO. 88 IN CODE)
  // FOR TURN OFF BUTTON, REQUEST / ACTION COMMAND WILL BE : /LED=OFF (POST-RELATES TO LINE NO. 95 IN CODE)
  // FOLLOW LINK TO UNDERSTAND BUTTON CODE IN HTML : https://www.w3schools.com/tags/tag_button.asp
  // FOLLOW LINK TO UNDERSTAND HREF CODE IN HTML : https://www.w3schools.com/tags/att_a_href.asp
  
  client.println("<a href=\"/LED=ON\"\"><button>ON</button></a>");   // ON BUTTON CREATION WITH REQUEST COMMAND
  client.println("<a href=\"/LED=OFF\"\"><button>OFF</button></a><br />");  // OFF BUTTON CREATION WITH REQUEST COMMAND
  client.println("</html>");    // END TAG OF HTML CODE
 
  Serial.println("Client disonnected");    // AFTER EXECUTION OF EACH REQUEST, CLIENT RELEASES THE CHANNEL FOR NEXT COMMAND.  
}
